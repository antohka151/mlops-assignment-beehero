## ðŸ§± Key Architectural Decisions

This file was generated with a help of GenAI based on the README.md and additional high-level details.  
In production I would create a separate ADR document, with less water.

### 1. **Modular Pipeline Design**
The pipeline is decomposed into independent, reusable components: `DataLoader`, `OutlierRemover`, `FeaturePreprocessor`, `ColonyStrengthClassifier`, `Trainer`, and `Evaluator`. This modularity ensures high cohesion and low coupling, making the system easier to test, maintain, and extend.

---

### 2. **Configuration-Driven Architecture**
All components are fully configurable via a centralized `config.yaml` file. Each high-level module has its own configuration block, enabling reproducibility, transparency, and seamless integration with MLflow.

---

### 3. **Feature Store Pattern for Preprocessing**
Feature engineering is implemented using a declarative feature store pattern. Each transformation step is defined in the config with:
- A readable name
- A reference to the transformation class
- Step-specific parameters

This allows dynamic construction of preprocessing pipelines and supports versioning of transformations.

---

### 4. **Outlier Removal as a Separate Component**
Outlier removal is handled by a dedicated `OutlierRemover` component, separate from the sklearn-compatible feature pipeline. This is necessary because outlier removal may affect both `X` and `y`, which violates sklearn's transformer assumptions. This separation improves clarity and correctness.

---

### 5. **MLflow Integration with Feature Hashing**
MLflow is used for experiment tracking, model versioning, and artifact logging. To ensure reproducibility and traceability, a hash of the entire feature engineering pipeline is computed and logged as a parameter in MLflow. This guarantees that even small changes in preprocessing logic are reflected in the experiment metadata.

---

### 6. **FastAPI-Based Model Serving**
A FastAPI service exposes the trained model via REST endpoints:
- `GET /health` for health checks
- `POST /predict` for inference

The API uses Pydantic schemas for validation and is designed for production-readiness and easy integration.

---

### 7. **Sklearn-Compatible Custom Components**
All custom transformers and models implement the sklearn interface (`fit`, `transform`, `fit_transform`), allowing them to be composed into sklearn pipelines and used with tools like `GridSearchCV`.

---

### 8. **Clear Separation of Responsibilities**
Each script has a single responsibility:
- `train.py`: Assembles and trains the pipeline
- `evaluate.py`: Evaluates the trained model
- `train_pipeline.py`: Entry point with MLflow integration
- `serve_api.py`: Launches the prediction API

This structure improves maintainability and aligns with production best practices.

---

### 9. **Lightweight Logging and Testing**
A simple logging utility provides consistent logs across components. Unit tests cover all major modules, and the project is CI-ready via `make test`.

---

### 10. **Adoption of `uv` for Dependency Management**

The project uses [`uv`](https://github.com/astral-sh/uv) as the primary tool for dependency resolution and virtual environment management. This decision was made based on the following advantages over traditional tools like `pip`, `pipenv`, or `poetry`:

- **Blazing Fast Performance**: `uv` is written in Rust and significantly outperforms `pip` and `poetry` in dependency resolution and installation speed, reducing setup time in CI/CD pipelines and local development.
- **PEP 582 Support**: `uv` supports PEP 582 (`__pypackages__`), enabling zero-config, per-project environments without the need for virtualenvs or `.venv` folders.
- **Compatibility with `pyproject.toml`**: `uv` works seamlessly with `pyproject.toml`, allowing for modern, standardized dependency declarations.
- **Deterministic Installs**: Lockfiles generated by `uv` ensure reproducible environments across machines and deployments.
- **Developer Experience**: The CLI is intuitive and minimal, reducing cognitive overhead for contributors and simplifying onboarding.